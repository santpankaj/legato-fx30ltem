\hypertarget{le__kernel_module__interface_8h}{}\section{le\+\_\+kernel\+Module\+\_\+interface.\+h File Reference}
\label{le__kernel_module__interface_8h}\index{le\+\_\+kernel\+Module\+\_\+interface.\+h@{le\+\_\+kernel\+Module\+\_\+interface.\+h}}
{\ttfamily \#include \char`\"{}legato.\+h\char`\"{}}\\*
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define {\bfseries L\+E\+\_\+\+K\+E\+R\+N\+E\+L\+M\+O\+D\+U\+L\+E\+\_\+\+N\+A\+M\+E\+\_\+\+L\+EN}~60\hypertarget{le__kernel_module__interface_8h_a6c339a7e719bae5c6082a0033b1feee1}{}\label{le__kernel_module__interface_8h_a6c339a7e719bae5c6082a0033b1feee1}

\item 
\#define {\bfseries L\+E\+\_\+\+K\+E\+R\+N\+E\+L\+M\+O\+D\+U\+L\+E\+\_\+\+N\+A\+M\+E\+\_\+\+L\+E\+N\+\_\+\+B\+Y\+T\+ES}~61\hypertarget{le__kernel_module__interface_8h_ad8e43e8ccbec4aa9d5a92c75c2a0f812}{}\label{le__kernel_module__interface_8h_ad8e43e8ccbec4aa9d5a92c75c2a0f812}

\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef void($\ast$ \hyperlink{le__kernel_module__interface_8h_ad963f95149e18959c02660a083a999f5}{le\+\_\+kernel\+Module\+\_\+\+Disconnect\+Handler\+\_\+t}) (void $\ast$)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{le__kernel_module__interface_8h_ab354beced24de671b42888dad6b1430e}{le\+\_\+kernel\+Module\+\_\+\+Connect\+Service} (void)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__kernel_module__interface_8h_a929bcd41d4f6173b888fe9c3106c0166}{le\+\_\+kernel\+Module\+\_\+\+Try\+Connect\+Service} (void)
\item 
void \hyperlink{le__kernel_module__interface_8h_a812c3a5b37dbe508ffa8a2664af6e782}{le\+\_\+kernel\+Module\+\_\+\+Set\+Server\+Disconnect\+Handler} (\hyperlink{le__kernel_module__interface_8h_ad963f95149e18959c02660a083a999f5}{le\+\_\+kernel\+Module\+\_\+\+Disconnect\+Handler\+\_\+t} disconnect\+Handler, void $\ast$context\+Ptr)
\item 
void \hyperlink{le__kernel_module__interface_8h_a47e2e278a242ea5abbc6a9a7fe3d422e}{le\+\_\+kernel\+Module\+\_\+\+Disconnect\+Service} (void)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__kernel_module__interface_8h_a9c2e966ce7469e0e299067d3738f9f1b}{le\+\_\+kernel\+Module\+\_\+\+Load} (const char $\ast$L\+E\+\_\+\+N\+O\+N\+N\+U\+LL module\+Name)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__kernel_module__interface_8h_ab5f32b97b1af07b87dbfc2be30703ac7}{le\+\_\+kernel\+Module\+\_\+\+Unload} (const char $\ast$L\+E\+\_\+\+N\+O\+N\+N\+U\+LL module\+Name)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Legato \hyperlink{c_kernelModule}{Linux Kernel Module A\+PI} include file.

Copyright (C) Sierra Wireless Inc. 

\subsection{Typedef Documentation}
\index{le\+\_\+kernel\+Module\+\_\+interface.\+h@{le\+\_\+kernel\+Module\+\_\+interface.\+h}!le\+\_\+kernel\+Module\+\_\+\+Disconnect\+Handler\+\_\+t@{le\+\_\+kernel\+Module\+\_\+\+Disconnect\+Handler\+\_\+t}}
\index{le\+\_\+kernel\+Module\+\_\+\+Disconnect\+Handler\+\_\+t@{le\+\_\+kernel\+Module\+\_\+\+Disconnect\+Handler\+\_\+t}!le\+\_\+kernel\+Module\+\_\+interface.\+h@{le\+\_\+kernel\+Module\+\_\+interface.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+kernel\+Module\+\_\+\+Disconnect\+Handler\+\_\+t}{le_kernelModule_DisconnectHandler_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$ le\+\_\+kernel\+Module\+\_\+\+Disconnect\+Handler\+\_\+t) (void $\ast$)}\hypertarget{le__kernel_module__interface_8h_ad963f95149e18959c02660a083a999f5}{}\label{le__kernel_module__interface_8h_ad963f95149e18959c02660a083a999f5}
Type for handler called when a server disconnects. 

\subsection{Function Documentation}
\index{le\+\_\+kernel\+Module\+\_\+interface.\+h@{le\+\_\+kernel\+Module\+\_\+interface.\+h}!le\+\_\+kernel\+Module\+\_\+\+Connect\+Service@{le\+\_\+kernel\+Module\+\_\+\+Connect\+Service}}
\index{le\+\_\+kernel\+Module\+\_\+\+Connect\+Service@{le\+\_\+kernel\+Module\+\_\+\+Connect\+Service}!le\+\_\+kernel\+Module\+\_\+interface.\+h@{le\+\_\+kernel\+Module\+\_\+interface.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+kernel\+Module\+\_\+\+Connect\+Service(void)}{le_kernelModule_ConnectService(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void le\+\_\+kernel\+Module\+\_\+\+Connect\+Service (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{le__kernel_module__interface_8h_ab354beced24de671b42888dad6b1430e}{}\label{le__kernel_module__interface_8h_ab354beced24de671b42888dad6b1430e}
Connect the current client thread to the service providing this A\+PI. Block until the service is available.

For each thread that wants to use this A\+PI, either Connect\+Service or Try\+Connect\+Service must be called before any other functions in this A\+PI. Normally, Connect\+Service is automatically called for the main thread, but not for any other thread. For details, see \hyperlink{apiFilesC_apiFilesC_client}{Client-\/specific Functions}.

This function is created automatically. \index{le\+\_\+kernel\+Module\+\_\+interface.\+h@{le\+\_\+kernel\+Module\+\_\+interface.\+h}!le\+\_\+kernel\+Module\+\_\+\+Disconnect\+Service@{le\+\_\+kernel\+Module\+\_\+\+Disconnect\+Service}}
\index{le\+\_\+kernel\+Module\+\_\+\+Disconnect\+Service@{le\+\_\+kernel\+Module\+\_\+\+Disconnect\+Service}!le\+\_\+kernel\+Module\+\_\+interface.\+h@{le\+\_\+kernel\+Module\+\_\+interface.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+kernel\+Module\+\_\+\+Disconnect\+Service(void)}{le_kernelModule_DisconnectService(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void le\+\_\+kernel\+Module\+\_\+\+Disconnect\+Service (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{le__kernel_module__interface_8h_a47e2e278a242ea5abbc6a9a7fe3d422e}{}\label{le__kernel_module__interface_8h_a47e2e278a242ea5abbc6a9a7fe3d422e}
Disconnect the current client thread from the service providing this A\+PI.

Normally, this function doesn\textquotesingle{}t need to be called. After this function is called, there\textquotesingle{}s no longer a connection to the service, and the functions in this A\+PI can\textquotesingle{}t be used. For details, see \hyperlink{apiFilesC_apiFilesC_client}{Client-\/specific Functions}.

This function is created automatically. \index{le\+\_\+kernel\+Module\+\_\+interface.\+h@{le\+\_\+kernel\+Module\+\_\+interface.\+h}!le\+\_\+kernel\+Module\+\_\+\+Load@{le\+\_\+kernel\+Module\+\_\+\+Load}}
\index{le\+\_\+kernel\+Module\+\_\+\+Load@{le\+\_\+kernel\+Module\+\_\+\+Load}!le\+\_\+kernel\+Module\+\_\+interface.\+h@{le\+\_\+kernel\+Module\+\_\+interface.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+kernel\+Module\+\_\+\+Load(const char $\ast$\+L\+E\+\_\+\+N\+O\+N\+N\+U\+L\+L module\+Name)}{le_kernelModule_Load(const char *LE_NONNULL moduleName)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+kernel\+Module\+\_\+\+Load (
\begin{DoxyParamCaption}
\item[{const char $\ast$L\+E\+\_\+\+N\+O\+N\+N\+U\+LL}]{module\+Name}
\end{DoxyParamCaption}
)}\hypertarget{le__kernel_module__interface_8h_a9c2e966ce7469e0e299067d3738f9f1b}{}\label{le__kernel_module__interface_8h_a9c2e966ce7469e0e299067d3738f9f1b}
Load the specified kernel module that was bundled with a Legato system.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if the module has been successfully loaded into the kernel.
\item L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND if the named module was not found in the system.
\item L\+E\+\_\+\+F\+A\+U\+LT if errors were encountered when loading the module, or one of the module\textquotesingle{}s dependencies. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em module\+Name} & Name of the module to load. \\
\hline
\end{DoxyParams}
\index{le\+\_\+kernel\+Module\+\_\+interface.\+h@{le\+\_\+kernel\+Module\+\_\+interface.\+h}!le\+\_\+kernel\+Module\+\_\+\+Set\+Server\+Disconnect\+Handler@{le\+\_\+kernel\+Module\+\_\+\+Set\+Server\+Disconnect\+Handler}}
\index{le\+\_\+kernel\+Module\+\_\+\+Set\+Server\+Disconnect\+Handler@{le\+\_\+kernel\+Module\+\_\+\+Set\+Server\+Disconnect\+Handler}!le\+\_\+kernel\+Module\+\_\+interface.\+h@{le\+\_\+kernel\+Module\+\_\+interface.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+kernel\+Module\+\_\+\+Set\+Server\+Disconnect\+Handler(le\+\_\+kernel\+Module\+\_\+\+Disconnect\+Handler\+\_\+t disconnect\+Handler, void $\ast$context\+Ptr)}{le_kernelModule_SetServerDisconnectHandler(le_kernelModule_DisconnectHandler_t disconnectHandler, void *contextPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}void le\+\_\+kernel\+Module\+\_\+\+Set\+Server\+Disconnect\+Handler (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+kernel\+Module\+\_\+\+Disconnect\+Handler\+\_\+t}}]{disconnect\+Handler, }
\item[{void $\ast$}]{context\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{le__kernel_module__interface_8h_a812c3a5b37dbe508ffa8a2664af6e782}{}\label{le__kernel_module__interface_8h_a812c3a5b37dbe508ffa8a2664af6e782}
Set handler called when server disconnection is detected.

When a server connection is lost, call this handler then exit with L\+E\+\_\+\+F\+A\+T\+AL. If a program wants to continue without exiting, it should call longjmp() from inside the handler. \index{le\+\_\+kernel\+Module\+\_\+interface.\+h@{le\+\_\+kernel\+Module\+\_\+interface.\+h}!le\+\_\+kernel\+Module\+\_\+\+Try\+Connect\+Service@{le\+\_\+kernel\+Module\+\_\+\+Try\+Connect\+Service}}
\index{le\+\_\+kernel\+Module\+\_\+\+Try\+Connect\+Service@{le\+\_\+kernel\+Module\+\_\+\+Try\+Connect\+Service}!le\+\_\+kernel\+Module\+\_\+interface.\+h@{le\+\_\+kernel\+Module\+\_\+interface.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+kernel\+Module\+\_\+\+Try\+Connect\+Service(void)}{le_kernelModule_TryConnectService(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+kernel\+Module\+\_\+\+Try\+Connect\+Service (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{le__kernel_module__interface_8h_a929bcd41d4f6173b888fe9c3106c0166}{}\label{le__kernel_module__interface_8h_a929bcd41d4f6173b888fe9c3106c0166}
Try to connect the current client thread to the service providing this A\+PI. Return with an error if the service is not available.

For each thread that wants to use this A\+PI, either Connect\+Service or Try\+Connect\+Service must be called before any other functions in this A\+PI. Normally, Connect\+Service is automatically called for the main thread, but not for any other thread. For details, see \hyperlink{apiFilesC_apiFilesC_client}{Client-\/specific Functions}.

This function is created automatically.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if the client connected successfully to the service.
\item L\+E\+\_\+\+U\+N\+A\+V\+A\+I\+L\+A\+B\+LE if the server is not currently offering the service to which the client is bound.
\item L\+E\+\_\+\+N\+O\+T\+\_\+\+P\+E\+R\+M\+I\+T\+T\+ED if the client interface is not bound to any service (doesn\textquotesingle{}t have a binding).
\item L\+E\+\_\+\+C\+O\+M\+M\+\_\+\+E\+R\+R\+OR if the Service Directory cannot be reached. 
\end{DoxyItemize}
\end{DoxyReturn}
\index{le\+\_\+kernel\+Module\+\_\+interface.\+h@{le\+\_\+kernel\+Module\+\_\+interface.\+h}!le\+\_\+kernel\+Module\+\_\+\+Unload@{le\+\_\+kernel\+Module\+\_\+\+Unload}}
\index{le\+\_\+kernel\+Module\+\_\+\+Unload@{le\+\_\+kernel\+Module\+\_\+\+Unload}!le\+\_\+kernel\+Module\+\_\+interface.\+h@{le\+\_\+kernel\+Module\+\_\+interface.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+kernel\+Module\+\_\+\+Unload(const char $\ast$\+L\+E\+\_\+\+N\+O\+N\+N\+U\+L\+L module\+Name)}{le_kernelModule_Unload(const char *LE_NONNULL moduleName)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+kernel\+Module\+\_\+\+Unload (
\begin{DoxyParamCaption}
\item[{const char $\ast$L\+E\+\_\+\+N\+O\+N\+N\+U\+LL}]{module\+Name}
\end{DoxyParamCaption}
)}\hypertarget{le__kernel_module__interface_8h_ab5f32b97b1af07b87dbfc2be30703ac7}{}\label{le__kernel_module__interface_8h_ab5f32b97b1af07b87dbfc2be30703ac7}
Unload the specified module. The module to be unloaded must be one that was bundled with the system.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if the module has been successfully unloaded from the kernel.
\item L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND if the named module was not found in the system.
\item L\+E\+\_\+\+F\+A\+U\+LT if errors were encountered during the module, or one of the module\textquotesingle{}s dependencies unloading. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em module\+Name} & Name of the module to unload. \\
\hline
\end{DoxyParams}
